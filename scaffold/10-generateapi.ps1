<#---
connection: sharepoint
api: post
title: Generate API
tag: generateapi
---#>
param (
	#$kitchenname = "nexi-infocast"
	$kitchenname = "magic-devices"

)
$verbose = $false
<# 

Helper functon to ensure that a path exists
#>
function EnsurePath($path) {
	if (-not (Test-Path $path)) {
		write-host "Creating directory  $path"
		$x = New-Item -Path  $path -ItemType Directory 
	}
	return $path
}

function SanitizeCode($cmd) {
	$cmd = [string]$cmd.Replace('.', '')
	$elements = $cmd -split '-'
	$TextInfo = (Get-Culture).TextInfo
	$elements = $elements | ForEach-Object { $TextInfo.ToTitleCase($_) }
	$cmd = $elements -join ''
	$cmd = [regex]::Replace($cmd, "([\W]+)", "")
	return $cmd
}
function SanitizeCmd($cmd) {
	$cmd = [string]$cmd.Replace('.json', '')
	$cmd = [string]$cmd.Replace('.', '-')
	$elements = $cmd -split '-'
	$TextInfo = (Get-Culture).TextInfo
	$elements = $elements | ForEach-Object { $TextInfo.ToTitleCase($_) }
	$cmd = $elements -join ''
	$cmd = [regex]::Replace($cmd, "([\W]+)", "")
	return $cmd
}

<#
## Function for generating the schema
#>
function MakeSchema($name) {
	$structName = SanitizeCmd($name)

	$filename = "$($ENV:KITCHENROOT)/$($kitchenname)/.koksmat/workdir/$name"

	if (-not (Test-Path $filename)) {
		write-host "File $filename does not exist"
		return $structName 
	}
	$outputfilename = "$schemaPath/$name.go"

	$go = json2struct -f $filename 


	if ([string]$go.IndexOf("package generated") -eq -1) {
		continue
	}

	$go = $go -replace "JSONToStruct", $structName
	$go = $go -replace "package generated", "package schemas"
			
				
	Out-File -FilePath $outputfilename  -InputObject $go -Encoding utf8NoBOM
	return $structName
}
<#
## Function for making the rest endpoint
#>
function MakeUsecase($stationTag, $scriptTag, $scriptname, $apiverb, $stationtitle, $scripttitle, $inputSchema, $outputSchema, $requestParams, $pwshParamMap, $kitchenname, $stationname, $inputFile, $outputFile) {

	$functionName = "$(SanitizeCode($stationTag))$(SanitizeCode($scriptTag))$(SanitizeCode($apiverb))"
	$functionName = $functionName.Replace(".", "")

	$requestBody = $requestParams
	$resultMapping = ""
	$inputMapping = ""
	if ($null -ne $inputFile -and $inputFile -ne "") {
	
		$inputMapping = @"
	body, inputErr := json.Marshal(input.Body)
		if inputErr != nil {
			return inputErr
		}

		inputErr = os.WriteFile(path.Join(utils.WorkDir("$($kitchenname)"), "$($inputFile)"), body, 0644)
		if inputErr != nil {
			return inputErr
		}

"@
		$inputFile = "$($scriptname).json"
	}
	if ($null -eq $outputSchema ) {
		$outputSchema = "string"
	}
	else {
		$outputSchema = "schemas.$outputSchema"
		$resultMapping = @"

resultingFile := path.Join(utils.WorkDir("$($kitchenname)"), "$($outputFile)")
data, err := os.ReadFile(resultingFile)
if (err != nil) {
	return err
}
resultObject := $($outputSchema){}
err = json.Unmarshal(data, &resultObject)
*output = resultObject
"@
	}
	if ($null -ne $inputSchema ) {
		
		$requestBody += "Body  schemas.$inputSchema ``json:""body"" binding:""required""``"
	}

	$go = @"
// -------------------------------------------------------------------
// Generated by 365admin-publish/api/20 makeschema.ps1
// -------------------------------------------------------------------
/*
---
title: $($script.title)
---
*/
package endpoints
import (
"context"
"encoding/json"
"os"
"path"
"github.com/swaggest/usecase"
"github.com/magicbutton/$($kitchenname)/schemas"
"github.com/magicbutton/$($kitchenname)/execution"
"github.com/magicbutton/$($kitchenname)/utils"
)
func $functionName() usecase.Interactor {
type Request struct {
	
	$requestBody

}
u := usecase.NewInteractor(func(ctx context.Context, input Request, output *$outputSchema) error {
	$inputMapping
	_, err := execution.ExecutePowerShell("john","*","$kitchenname","$stationname","$scriptname","$journeyid" $pwshParamMap)
	if (err != nil) {
		return err
	}
	$resultMapping
	return err

})
u.SetTitle("$($scripttitle)")
// u.SetExpectedErrors(status.InvalidArgument)
u.SetTags("$($stationtitle)")
return u
}
"@        
	$subpath = "/$($stationTag)/$($scriptTag)"
	$filename = "$endpointsPath/$($station.tag)-$($script.tag)-$($script.api).go"
	if ($verbose) { write-host $filename }
	Out-File -FilePath $filename  -InputObject $go -Encoding utf8NoBOM

	return "r.Method(http.MethodPost, ""$subpath"", nethttp.NewHandler($functionName()))"
}
<#
## Function for generating the command
#>

# ------------------------------------------------------------------------------------------------------------------
#
#    MakeCmd
#
# ------------------------------------------------------------------------------------------------------------------
function MakeCmd($stationTag, $scriptTag, $scriptname, $apiverb, $stationtitle, $scripttitle, $inputSchema, $outputSchema, $requestParams, $pwshParamMap, $kitchenname, $stationname, $inputFile, $outputFile, $paramsCount, $cobraArgNames) {

	$functionName = "$(SanitizeCode($stationTag))$(SanitizeCode($scriptTag))$(SanitizeCode($apiverb))"
	$functionName = $functionName.Replace(".", "")

	$requestBody = $requestParams
	$resultMapping = ""
	$inputMapping = ""
	if ($null -ne $inputFile -and $inputFile -ne "") {
	
		$inputMapping = @"
		inputErr := os.WriteFile(path.Join(utils.WorkDir("$($kitchenname)"), "$($inputFile)"), body, 0644)
		if inputErr != nil {
			return nil,inputErr
		}

"@
		$inputFile = "$($scriptname).json"
	}
	if ($null -eq $outputSchema ) {
		$outputSchema = "string"

		$resultMapping = @"
utils.PrintSkip2FirstAnd2LastLines(string(result))
return nil, nil

"@		
	}
	else {
		$outputSchema = "schemas.$outputSchema"
		$resultMapping = @"

resultingFile := path.Join(utils.WorkDir("$($kitchenname)"), "$($outputFile)")
data, err := os.ReadFile(resultingFile)
if (err != nil) {
	return nil,err
}
resultObject := $($outputSchema){}
err = json.Unmarshal(data, &resultObject)
if (utils.Output == "json"){
	fmt.Println(string(data))
}
utils.PrintSkip2FirstAnd2LastLines(string(result))

return nil,nil

"@
	}
	if ($null -ne $inputSchema ) {
		
		$requestBody = "body []byte,args  []string"
	}
	else {
		$requestBody = "args  []string"
	}

	$go = @"
// -------------------------------------------------------------------
// Generated by 365admin-publish
// -------------------------------------------------------------------
/*
---
title: $($script.title)
---
*/
package cmds
import (
"context"
"encoding/json"
"os"
"path"
"fmt"
"github.com/spf13/cobra"
"github.com/magicbutton/$($kitchenname)/schemas"
"github.com/magicbutton/$($kitchenname)/execution"
"github.com/magicbutton/$($kitchenname)/utils"
)
func $functionName(ctx context.Context, $requestBody)  ( *$outputSchema, error) {
	$inputMapping
	result, pwsherr := execution.ExecutePowerShell("john","*","$kitchenname","$stationname","$scriptname","$journeyid" $pwshParamMap)
	if (pwsherr != nil) {
		return nil,pwsherr
	}
	$resultMapping
	


}
"@        
	$subpath = "/$($stationTag)/$($scriptTag)"
	$filename = "$cmdsPath/$($station.tag)-$($script.tag)-$($script.api).go"
	
	if ($verbose) { write-host $filename }
	Out-File -FilePath $filename  -InputObject $go -Encoding utf8NoBOM

	$readbody = ""
	$bodyarg = ""
	if ($null -ne $inputFile -and $inputFile -ne "") {
		$bodyarg = ",body"
		$readBody = @"
body, err := os.ReadFile(args[0])
if err != nil {
	panic(err)
}

"@
	}


	$cmdCall = @"
	$($functionName)Cmd := &cobra.Command{
		Use:   "$($script.tag) $($cobraArgNames)",
		Short: "$($script.title)",
		Long:  ``$($script.description)``,
		Args: cobra.MinimumNArgs($($paramsCount)),
		Run: func(cmd *cobra.Command, args []string) {
			ctx := cmd.Context()
			$readBody
			cmds.$functionName(ctx$bodyarg,args)
		},
	}
	$($stationTag)Cmd.AddCommand($($functionName)Cmd)

"@
	return $cmdCall
}

# ------------------------------------------------------------------------------------------------------------------
#
#    MakeService
#
# ------------------------------------------------------------------------------------------------------------------
function MakeService($stationTag, $scriptTag, $scriptname, $apiverb, $stationtitle, $scripttitle, $inputSchema, $outputSchema, $requestParams, $pwshParamMap, $kitchenname, $stationname, $inputFile, $outputFile) {

	$functionName = "$(SanitizeCode($stationTag))$(SanitizeCode($scriptTag))$(SanitizeCode($apiverb))"
	$functionName = $functionName.Replace(".", "")

	$requestBody = $requestParams
	$resultMapping = ""
	$inputMapping = ""
	if ($null -ne $inputFile -and $inputFile -ne "") {
	
		$inputMapping = @"
inputErr := os.WriteFile(path.Join(utils.WorkDir("$($kitchenname)"), "$($inputFile)"), body, 0644)
if inputErr != nil {
	return nil,inputErr
}

"@
		$inputFile = "$($scriptname).json"
	}
	if ($null -eq $outputSchema ) {
		$outputSchema = "string"
		$resultMapping = "return nil, nil"
	}
	else {
		$outputSchema = "schemas.$outputSchema"
		$resultMapping = @"

resultingFile := path.Join(utils.WorkDir("$($kitchenname)"), "$($outputFile)")
data, err := os.ReadFile(resultingFile)
if (err != nil) {
	return nil,err
}
resultObject := $($outputSchema){}
err = json.Unmarshal(data, &resultObject)
return &resultObject,nil

"@
	}
	if ($null -ne $inputSchema ) {
		
		$requestBody = "body []byte,args  []string"
	}
	else {
		$requestBody = "args  []string"
	}

	$go = @"
// -------------------------------------------------------------------
// Generated by 365admin-publish 
// Service wrapper  v1
// -------------------------------------------------------------------
/*
---
title: $($script.title)
---
*/
package cmds
import (
"context"
"encoding/json"
"os"

"path"
"github.com/nats-io/nats.go"
"github.com/nats-io/nats.go/micro"
"github.com/spf13/cobra"
"github.com/magicbutton/$($kitchenname)/schemas"
"github.com/magicbutton/$($kitchenname)/execution"
"github.com/magicbutton/$($kitchenname)/utils"
)
func $functionName(ctx context.Context, $requestBody)  ( *$outputSchema, error) {
$inputMapping
_, pwsherr := execution.ExecutePowerShell("john","*","$kitchenname","$stationname","$scriptname","$journeyid" $pwshParamMap)
if (pwsherr != nil) {
	return nil,pwsherr
}
$resultMapping
	
// end result mapping

func init(){
	
}
}
"@        
	$subpath = "/$($stationTag)/$($scriptTag)"
	$filename = "$servicePath/$($station.tag)-$($script.tag)-$($script.api).go"
	
	if ($verbose) { write-host $filename }
	Out-File -FilePath $filename  -InputObject $go -Encoding utf8NoBOM

	$readbody = ""
	$bodyarg = ""
	if ($null -ne $inputFile -and $inputFile -ne "") {
		$bodyarg = ",body"
		$readBody = @"
body, err := os.ReadFile(args[0])
if err != nil {
	panic(err)
}

"@
	}


	$cmdCall = @"
	$($functionName)Cmd := &cobra.Command{
		Use:   "$($script.tag)",
		Short: "$($script.title)",
		Long:  ``$($script.description)``,
		Run: func(cmd *cobra.Command, args []string) {
			ctx := cmd.Context()
			$readBody
			cmds.$functionName(ctx$bodyarg,args)
		},
	}
	$($stationTag)Cmd.AddCommand($($functionName)Cmd)

"@
	return $cmdCall
}


<#
____________________________________________________________________________________________________________________

Start of flow
____________________________________________________________________________________________________________________
#>
$goModuleFilename = join-path $ENV:KITCHENROOT $kitchenname ".koksmat" "app" "go.mod"
if (-not (Test-Path $goModuleFilename)) {
	write-host "File $goModuleFilename does not exist" -ForegroundColor Red
	write-host "You need to run the `365admin-publish scaffold init` command first" -ForegroundColor Yellow
	
	return
}

$goModule = Get-Content -Path $goModuleFilename
$moduleName = $goModule[0].Split(" ")[1]

<#
Read the kitchen status
#>
$kitchenStatus = koksmat kitchen stations $kitchenname | ConvertFrom-Json


$endpointsPath = EnsurePath (join-path $ENV:KITCHENROOT $kitchenname ".koksmat" "app" "endpoints")
$schemaPath = EnsurePath (join-path $ENV:KITCHENROOT $kitchenname ".koksmat" "app" "schemas")
$cmdsPath = EnsurePath (join-path $ENV:KITCHENROOT $kitchenname ".koksmat" "app" "cmds")
$servicePath = EnsurePath (join-path $ENV:KITCHENROOT $kitchenname ".koksmat" "app" "services")




<#
## Looping over stations and scripts
"Main" program
#>

# ------------------------------------------------------------------------------------------------------------------
#
#    Loop
#
# --------
$registrations = ""

$stationCmd = @"
package magicapp

import (
	"os"
	"fmt"
	"log"
	"net/http"
	"runtime/debug"
	"strings"
	"github.com/spf13/cobra"
	"$modulename/endpoints"
	"$modulename/cmds"
	"$modulename/utils"


)


func RegisterCmds(){
	utils.RootCmd.PersistentFlags().StringVarP(&utils.Output, "output", "o", "", "Output format (json, yaml, xml, etc.)")


"@


foreach ($station in $kitchenStatus.stations) {
	if ($station.scripts.Count -lt 1) {
		continue
	}
	$hasApi = $false
	foreach ($script in $station.scripts) {
		if ($script.name.EndsWith(".go")) {
			continue
		}
		if ($script.api -ne "") {
			$hasApi = $true
			break
		}
	}
	if (-not $hasApi) {
		continue
	}
	$stationCmd += @"
	$($station.tag)Cmd := &cobra.Command{
	   Use:   "$($station.tag)",
	   Short: "$($station.title)",
	   Long:  ``$($station.description)``,
   }

"@
 foreach ($script in $station.scripts) {
		if ($script.name.EndsWith(".go")) {
			continue
		}
		$inputSchema = $null
		$outputSchema = $null
		$generateApi = $script.api -ne ""
		if ($generateApi) {
			$stationLeaf = Split-Path $station.path -Leaf
			$meta = koksmat kitchen script meta $script.name -k $kitchenname -s $stationLeaf | ConvertFrom-Json
			if ($script.input -ne "") {
               
				$inputSchema = MakeSchema($script.input)

		
			}
			if ($script.output -ne "") {
               
				$outputSchema = MakeSchema($script.output)

		
			}
			$pwshParamMap = ""
			$pwshParamMap2 = ""
			$pwshParamMap3 = ""
			$requestParams = ""
			$functionArgumentArray = @()
			if ($meta.parameters -and $meta.parameters.Count -gt 0) {
				$argIndex = 0
				if ($script.input -ne "") {
					$argIndex = 1 # First argument will contain path to the input file
				}
				foreach ($parameter in $meta.parameters) {
					$sanitizedName = SanitizeCode($parameter.name)
					$pwshParamMap += ", ""-$($parameter.name)"", input.$sanitizedName"
					if ($parameter.name -eq "kitchenname") {
						$pwshParamMap2 += ", ""-$($parameter.name)"", GetDirectory(args[$argIndex])"
					}
					else {
						$pwshParamMap2 += ", ""-$($parameter.name)"", args[$argIndex]"
					}
					# $pwshParamMap2 += ", ""-$($parameter.name)"", args[$argIndex]"
					$pwshParamMap3 += " $($parameter.name)"
					$requestParams += "$sanitizedName  string ``query:""$($parameter.name)"" binding:""required""`` `n"
					$functionArgumentArray += "$sanitizedName string"
					$argIndex++
				}
			}
			$functionArguments = $functionArgumentArray -join ", "
			$cmds = MakeCmd $station.tag $script.tag $script.name $script.api $station.title $script.title $inputSchema $outputSchema $functionArguments $pwshParamMap2 $kitchenname $station.name $script.input $script.output $meta.parameters.Count $pwshParamMap3
			$stationCmd += $cmds
			$registrations += MakeUsecase $station.tag $script.tag $script.name $script.api $station.title $script.title $inputSchema $outputSchema  $requestParams $pwshParamMap $kitchenname $station.name $script.input $script.output
			$registrations += "`n"
			# $services = MakeService $station.tag $script.tag $script.name $script.api $station.title $script.title $inputSchema $outputSchema $functionArguments $pwshParamMap2 $kitchenname $station.name $script.input $script.output

		}
   
		
 }

 $stationCmd += @"
 
utils.RootCmd.AddCommand($($station.tag)Cmd)

"@
}

$stationCmd += @"
}
"@



<#
## Binding the endpoints
Creating the file that binds the endpoints
#>
$binding = @"
// -------------------------------------------------------------------
// Generated by 365admin-publish
// -------------------------------------------------------------------

package endpoints

import (
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/swaggest/rest/nethttp"
	"github.com/swaggest/rest/web"
)

func AddEndpoints(s *web.Service, jwtAuth func(http.Handler) http.Handler) {
	s.Route("/v1", func(r chi.Router) {
		r.Group(func(r chi.Router) {
			//r.Use(adminAuth, nethttp.HTTPBasicSecurityMiddleware(s.OpenAPICollector, "User", "User access"))
			r.Use(jwtAuth, nethttp.HTTPBearerSecurityMiddleware(s.OpenAPICollector, "Bearer", "", ""))
			//	r.Use(rateLimitByAppId(50))
			//r.Method(http.MethodPost, "/", nethttp.NewHandler(ExchangeCreateRoomsPost()))
			$registrations
		})
	})

}

"@
$bindingfilename = "$endpointsPath/bindings.go"
Out-File -FilePath $bindingfilename  -InputObject $binding -Encoding utf8NoBOM


$cmdsfilename = "$($ENV:KITCHENROOT)/$kitchenname/.koksmat/app/magicapp/cmds2.go"
Out-File -FilePath $cmdsfilename  -InputObject $stationCmd  -Encoding utf8NoBOM


<#
## Creating the cmds.go file 

The `cmds.go` file contains the commands that are used to start the API server.

#>

$cmdsCode = @"
// fodkold
package magicapp

import (
	"fmt"
	"log"
	"net/http"
	"runtime/debug"
	"strings"

	"$modulename/endpoints"
	"$modulename/cmds"
	"github.com/spf13/cobra"
	"github.com/swaggest/rest/web"
	swgui "github.com/swaggest/swgui/v4emb"
	"$modulename/utils"
)

func StartAPIServer(title string, version string, description string, port int) {
	info, _ := debug.ReadBuildInfo()

	// split info.Main.Path by / and get the last element
	s1 := strings.Split(info.Main.Path, "/")
	name := s1[len(s1)-1]
	root := fmt.Sprintf("/v1/%s", name)
	docs := fmt.Sprintf("%s/docs", root)
	s := web.DefaultService()

	// Init API documentation schema.
	s.OpenAPI.Info.Title = title
	s.OpenAPI.Info.WithDescription(description)
	s.OpenAPI.Info.Version = version

	// sharedSettings(s)
	endpoints.AddEndpoints(s, Authenticator)
	// addAdminEndpoints(s, Authenticator)
	// addExchangeEndpoints(s, Authenticator)
	// addCoreEndpoints(s, Authenticator)
	s.Docs(docs, swgui.New)
	log.Printf("Server started, read documentation at http://localhost:%d%s", port, docs)
	if err := http.ListenAndServe(fmt.Sprintf(":%d", port), s); err != nil {
		log.Fatal(err)
	}
}
func RegisterServeCmd(title string, description string, version string, port int) {
	listCmd := &cobra.Command{
		Use:   "serve",
		Short: "Serve the API",
		Long:  ``Serve the API``,
		Run: func(cmd *cobra.Command, args []string) {
			StartAPIServer(title, version, description, port)
		},
	}
	utils.RootCmd.AddCommand(listCmd)
}
"@

$cmdsfilename = "$($ENV:KITCHENROOT)/$kitchenname/.koksmat/app/magicapp/cmds.go"
Out-File -FilePath $cmdsfilename  -InputObject $cmdsCode  -Encoding utf8NoBOM

<#
## Creating the main.go file

Here we call the `koksmat` CLI to get the readme for the kitchen. We then create the main.go file and write the content to it. 
#>

$mainFilename = "$($ENV:KITCHENROOT)/$kitchenname/.koksmat/app/main.go"

$kitchenStatus = koksmat kitchen stations $kitchenname | ConvertFrom-Json
$markdown = $kitchenStatus.readme
$maincode = @"

package main

import (
	"runtime/debug"
	"strings"

	"$moduleName/magicapp"
	"$moduleName/utils"
)


func main() {
	info, _ := debug.ReadBuildInfo()

	// split info.Main.Path by / and get the last element
	s1 := strings.Split(info.Main.Path, "/")
	name := s1[len(s1)-1]
	description := ``$markdown``
	magicapp.Setup(".env")
	magicapp.RegisterServeCmd("$($kitchenStatus.title)", description, "0.0.1", 8080)
	magicapp.RegisterCmds()
	utils.RootCmd.PersistentFlags().BoolVarP(&utils.Verbose, "verbose", "v", false, "verbose output")

	magicapp.Execute(name, "$($kitchenStatus.title)", "")
}
"@

if (-not (Test-Path $mainFilename)) {
	write-host "Creating file  $mainFilename"
	Out-File -FilePath $mainFilename  -InputObject $maincode  -Encoding utf8NoBOM
}
else {
	# Write-Host -ForegroundColor Cyan "Main file already exists"
}

<#
## Go statics checks
Finally make the go files clean
#>
Push-Location
Set-Location "$($ENV:KITCHENROOT)/$($kitchenname)/.koksmat/app"
goimports-reviser -rm-unused -set-alias -format ./...
go mod tidy
go install
Pop-Location
Start-Process $kitchenname